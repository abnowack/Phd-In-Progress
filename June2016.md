# Cython Notes

Based on [Cython: A Guide by Programmers by Kurt Smith](http://shop.oreilly.com/product/0636920033431.do)

### Compiler Directives
List is [available here](http://docs.cython.org/src/reference/compilation.html#compiler-directives)

### Statically Declared C Types

Speed up is mainly obtained by converting dynamic Python objects into statically defined C types. Done by using the `cdef` keyword.
```
cdef int a, b = 2
cdef float c = 3.14
cdef int *int_pointer
```
Pointers are supported, however * can't be used for dereferencing. The work-around is to use the zero-index array format
```
cdef double pi, *p_pi
p_pi = &pi
p_pi[0] = 3.14
```

Also struct members when using struct pointers are accessed using the dot operator (.) instead of the arrow operator (->).
```
cdef foo *p_foo = make_foo()
cdef int bar = p_foo.a + p_foo.b
```

Can statically declare built-in Python types as well
```
cdef list foo_list, bar_list
```
As well as mixing static and dynamic variables such as creating a dynamic tuple
```
cdef int a, b, c
int_tuple = (a, b, c)
```

However statically declaring Python types will avoid the expensive type and method lookups which is where most speed improvements are made.

One last note: Don't reference temporary Python objects, as they will be deleted through the garbage collector
```
b1 = b"A btye string"
b2 = b"and a second one"
cdef char *buf = b1 + b2
```
Instead create a temporary object, which may be dynamically or statically typed
```
# dynamic
tmp = s1 + s2
# static
cdef bytes tmp = s1 + s2

cdef char *buf = tmp
```

### Three Types of Functions
- def function_name(args)

  Python function compiled as type builtin_function_or_method which is not a C-function. It is a python extensible object with exceptions that attributes like __name__ are not modifiable in Cython. Return values are python objects. Usually 2-3 times performance improvements. Handles Exceptions automatically.

- cdef function_name(cdef args)

  Compiled as a C-function with C arguments and C return values. Can be called by other Cython code, but not by Python directly. Must wrap it in a def wrapper_function in the Cython code for external Python code to use. Must be aware of Python -> C type conversion and overflow errors.

- cpdef function_name(cdef args)

  Combines the functionality of two previous methods by compiling the function as a C function but provides a Python funciton wrapper of the same name. No performance difference compared to cdef function_name. However the return type is limited to those compatible with both C and Python. Return types of void, C pointers and C arrays are excluded.

### Passing Exceptions in Cython Functions

For cdef and cpdef, exceptions can be handled by having Cython either always check if an exception was raised, check only if it returns a specific value, or if the return value does not occur normally raise the exception everytime if that value is returned.

cpdef function(int i) except *:   # Always check global exception state if exception raised

cpdef function(int i) except? -1: # While -1 may be a valid return value, check if exception was raised if -1 is returned

cpdef function(int i) except -1:  # -1 is not possible as a return value normally, no exception check needed

### Type Casting

In Cython C-style type casts are done by using angle brackets <int> instead of paranthesis (int)

cdef int *ptr_i = <int*>var

Can even convert types to builtin Python types such as list

cdef list cast_list = <list>some_object

However if some_object is not compatible will get a generic SystemError message when trying to use list methods on cast_list. A solution is to ask Cython to check the type by using <list?> where ? indicates to check the type. A TypeError exception will be raised instead of the types are not compatible.

### Structs, Unions, Enums

In C:
```C
struct foo {
  int a;
  double b;
};

typedef struct typed_foo {
  int c;
  double d;
} typed_foo;

typed_foo bar;
```
In Cython:
```
cdef struct foo:
  int a
  double b

ctypedef struct typed_foo:
  int c
  double d

cdef typed_foo bar
```
Can use different initializations
```
cdef typed_foo bar = typed_foo(4, 3.14)
cdef typed_foo bar = typed_foo(c=4, d=3.14)

cdef typed_foo bar
bar.c = 4
bar.d = 3.14

cdef typed_foo bar = {'c': 4, 'd': 3.14}
```

While anonymous nested structs aren't supported, can use nested structs by assigning dummy names

In C:
```
struct nested {
  int outer_a;
  struct inner_ {
    int inner_a;
  } inner;
};
```

In Cython:
```
cdef struct _inner:
  int inner_a

cdef struct nested:
  int outer_a
  _inner inner
```

Enums can be declared in several ways, and may be anonymous (which are basically compile time integer constants).

```
cdef enum PRIMARY_COLOR:
  RED = 1
  YELLOW = 3
  BLUE = 5

cdef enum SECONDARY_COLOR:
  ORANGE, GREEN, PURPLE

cdef enum:
  SEED = 37
```

### Typedefs

Must be declared at the file scope, not inside functions.

```
ctypedef double real_type
ctypedef long integral_type
```

### Using For/While Loops Efficiently

By static typing the range argument and index variable, Cython will generate a direct C for/while loop everytime.
```
cdef unsigned int i, n = 100
for i in range(n):
  ...
```

For looping over builtin types and NumPy objects, statically typing the loop variable may introduce more overhead and slower code.

### Preprocessor DEFinitions

```
DEF PI = 3.1415
```

Supports IF/ELIF/ELSE statements. UNAME_[SYSNAME, RELEASE, VERSION, MACHINE, NODENAME] typedefs aredefined by Cython.
